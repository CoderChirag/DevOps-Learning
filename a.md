## Running Containers

### Introducing Containers

#### Introducing Container Technology

-   Software applications typically depend on other libraries, configuration files, or services provided by their runtime environment.
-   Traditionally, the runtime environment for a software application is installed in an operating system running on a physical host or virtual machine.
-   Any application dependencies are installed along with that operating system on the host.
    <br>

-   In Red Hat Enterprise Linux, packaging systems like RPM are used to help manage application dependencies.
-   When we install the `httpd` package, the RPM system ensures that the correct libraries and other dependencies for that package are also installed.
    <br>

-   The major drawback to traditionally deployed software applications is that these dependencies are entangled with the runtime environment.
-   An application might require versions of supporting software that are older or newer than the software provided with the operating system.
-   Similarly, two applications on the same system might require different versions of the same software that are incompatible with each other.
    <br>

-   One way to resolve these conflicts is to package and deploy the application as a container.
-   A **container** is a set of one or more processes that are isolated from the rest of the system.
    <br>

-   Think of a physical shipping container.
-   A shipping container is a standard way to package and ship goods.
-   It is labeled, loaded, unloaded, and transported from one location to another as a single box.
-   The container's contents are isolated from the contents of other containers so that they do not affect each other.
    <br>

-   Software containers are a way to package applications to simplify deployment and management.

#### Comparing Containers to Virtual Machines

-   Containers provide many of the same benefits as virtual machines, such as security, storage, and network isolation.
    <br>

-   Both technologies isolate their application libraries and runtime resources from the host operating system or hypervisor and vice versa.
    ![virtualization_vs_containers](./images/virtualization-vs-containers.png)
    <br>

-   Containers and Virtual Machines are different in the way they interact with hardware and the underlying operating system.
    <br>

-   **Virtualization :**

    -   Enables multiple operating systems to run simultaneously on a single hardware platform.
    -   Uses a **hypervisor** to divide hardware into multiple virtual hardware systems, allowing multiple operating systems to run side by side.
    -   Requires a complete operating system environment to support the application.
        <br>

-   Compare and contrast this with **Containers**, which :

    -   Run directly on the operating system, sharing hardware and OS resources across all containers on the system. This enables applications to stay lightweight and run swiftly in parallel.
    -   Share the same operating system kernel, isolate the containerized application processes from the rest of the system, and use any software compatible with that kernel.
    -   Require far fewer hardware resources than virtual machines, which also makes them quick to start and stop and reduces storage requirements.
        <br>

-   **Note**
    -   Some applications might not be suitable to run as a container. For example, applications accessing low-level hardware information might need more direct hardware access than containers generally provide.

#### Exploring the Implementation of Containers

-   Red Hat Enterprise Linux implements containers using core technologies such as :

    -   **Control Groups** (cgroups) for resource management.
    -   **Namespaces** for process isolation.
    -   **SELinux** and **Seccomp** (Secure Computing mode) to enforce security boundaries.

#### Planning for Containers

-   Containers are an efficient way to provide reusability and portability of hosted applications.
-   They can be easily moved from one environment to another, such as from development to production.
-   We can save multiple versions of a container and quickly access each one as needed.
    <br>

-   Containers are typically temporary, or ephemeral.
-   We can permanently save data generated by a running container in persistent storage, but the containers themselves usually run when needed, and then stop and are removed.
-   A new container process is started the next time that particular container is needed.

#### Running Containers from Container Images

-   Containers are run from container images. Container images serve as blueprints for creating containers.
    <br>

-   Container images package an application together with all its dependencies, such as :

    -   System libraries
    -   Programming language runtimes
    -   Programming language libraries
    -   Configuration settings
    -   Static data files

-   Container images are unchangeable, or immutable, files that include all the required code and dependencies to run a container.
    <br>

-   Container images are built according to specifications, such as the **Open Container Initiative (OCI)** image format specification.
-   These specifications define the format for container images, as well as the metadata about the container host operating systems and hardware architectures that the image supports.

#### Designing Container-based Architectures

-   We could install a complex software application made up of multiple services in a single container.
-   For example, we might have a web server that needs to use a database and a messaging system. But using one container for multiple services is hard to manage.
    <br>

-   A better design runs each component, the web server, the database, and the messaging system, in separate containers.
-   This way, updates and maintenance to individual application components do not affect other components or the application stack.

#### Managing Containers with Podman

-   A good way to start learning about containers is to work with individual containers on a single server acting as a container host.
-   Red Hat Enterprise Linux provides a set of container tools that we can use to do this, including :
    -   `podman`, which directly manages containers and container images.
    -   `skopeo`, which we can use to inspect, copy, delete, and sign images.
    -   `buildah`, which we can use to create new container images.
-   These tools are compatible with the **Open Container Initiative (OCI)**.
-   They can be used to manage any Linux containers created by OCI-compatible container engines, such as Docker.
-   These tools are specifically designed to run containers under Red Hat Enterprise Linux on a single-node container host.
    <br>

-   In this chapter, we will use `podman` and `skopeo` commands to run and manage containers and existing container images.

#### Running Rootless Containers

-   On the container host, we can run containers as the root user or as a regular, unprivileged user.
-   Containers run by non-privileged users are called **rootless containers**.
    <br>

-   Rootless containers are more secure, but have some restrictions.
-   For example, rootless containers cannot publish their network services through the container host's privileged ports (those below port 1024).
    <br>

-   We can run containers directly as root, if necessary, but this somewhat weakens the security of the system if a bug allows an attacker to compromise the container.

#### Managing Containers at Scale

-   New applications increasingly implement functional components using containers.
-   Those containers provide services that other parts of the application consume.
-   In an organization, managing a growing number of containers may quickly become an overwhelming task.
    <br>

-   Deploying containers at scale in production requires an environment that can adapt to some of the following challenges :

    -   The platform must ensure the availability of containers that provide essential services to customers.
    -   The environment must respond to application usage spikes by increasing or decreasing the running containers and load balancing the traffic.
    -   The platform should detect the failure of a container or a host and react accordingly.
    -   Developers might need an automated workflow to transparently and securely deliver new application versions to customers.
        <br>

-   **Kubernetes** is an orchestration service that makes it easier for us to deploy, manage, and scale container-based applications across a cluster of container hosts.
-   It helps manage DNS updates when we start new containers.
-   It helps redirect traffic to our containers using a load balancer, which also allows us to scale up and down the number of containers providing a service manually or automatically.
-   It also supports user-defined health checks to monitor our containers and to restart them if they fail.
    <br>

-   Red Hat provides a distribution of Kubernetes called **Red Hat OpenShift**.
-   OpenShift is a set of modular components and services built on top of the Kubernetes infrastructure.
-   It adds additional features, such as remote web-based management, multitenancy, monitoring and auditing, application life cycle management, and self-service instances for developers, among others.

-   **Note**

    -   In the enterprise, individual containers are not generally run from the command line.
    -   Instead, it is preferable to run containers in production using a Kubernetes-based platform, such as Red Hat OpenShift.
        <br>

    -   However, we might need to use commands to work with containers and images manually or at a small scale.
    -   To do this, we can install a set of container tools on a Red Hat Enterprise Linux 8 system.
        <br>
    -   This chapter focuses on this use case to help us better understand the core concepts behind containers, how they work, and how they can be useful.

### Running a Basic Container

#### Installing Container Management Tools

-   To get started with running and managing containers on our system, we must install the necessary command-line tools. Install the `container-tools` module with the `yum` command.<br> `$ yum module install container-tools`
    <br>
-   The `container-tools` module includes software packages that install several tools.
    <br>

-   **Note**

    -   By default, the system installs the fast stream tools, `container-tools:rhel8` that rebase on the latest, stable upstream version of the container tools every three months.
        <br>

    -   Alternative stable streams that lock in a particular version of the tools do not get feature updates. Red Hat plans to release new stable streams once a year that are supported for two years.

#### Selecting Container Images and Registries

-   A container registry is a repository for storing and retrieving container images.
-   Container images are uploaded, or pushed, to a container registry by a developer.
-   We download, or pull, those container images from the registry to a local system so that we can use them to run containers.
    <br>

-   we might use a public registry containing third-party images, or we might use a private registry controlled by our organization.
-   The source of our container images matters.
-   Just like any other software package, we must know whether we can trust the code in the container image.
-   Different registries have different policies about whether and how they provide, evaluate, and test container images submitted to them.
    <br>

-   Red Hat distributes certified container images through two main container registries that we can access with our Red Hat log in credentials.

    -   `registry.redhat.io` for containers based on official Red Hat products.
    -   `registry.connect.redhat.com` for containers based on third-party products.
        <br>

-   Red Hat is gradually phasing out an older registry, `registry.access.redhat.com`.
    <br>

-   The Red Hat Container Catalog (https://access.redhat.com/containers) provides a web-based interface that we can use to search these registries for certified content.

#### Container Naming Conventions

-   Container images are named based on the following fully qualified image name syntax :

-   `registry_name/user_name/image_name:tag`

    -   The `registry_name` is the name of the registry storing the image. It is usually the fully qualified domain name of the registry.

    -   The `user_name` represents the user or organization to which the image belongs.

    -   The `image_name` must be unique in the user namespace.

    -   The `tag` identifies the image version. If the image name includes no image tag, then latest is assumed.

#### Running Containers

-   To run a container on our local system, we must first pull a container image.
-   Use Podman to pull an image from a registry.
-   We should always use the fully qualified image name when pulling images.
-   The `podman pull` command pulls the image we specify from the registry and saves it locally :
    ```
    $ podman pull registry.access.redhat.com/ubi8/ubi:latest
    Trying to pull registry.access.redhat.com/ubi8/ubi:latest...Getting image source signatures
    Copying blob 77c58f19bd6e: 70.54 MiB / 70.54 MiB [=========================] 10s
    Copying blob 47db82df7f3f: 1.68 KiB / 1.68 KiB [===========================] 10s
    Copying config a1f8c9699786: 4.26 KiB / 4.26 KiB [==========================] 0s
    Writing manifest to image destination
    Storing signatures
    a1f8c969978652a6d1b2dfb265ae0c6c346da69000160cd3ecd5f619e26fa9f3
    ```
-   After retrieval, Podman stores images locally and we can list them using the `podman images` command :
    ```
    $ podman images
    REPOSITORY                            TAG      IMAGE ID       CREATED      SIZE
    registry.access.redhat.com/ubi8/ubi   latest   a1f8c9699786   5 weeks ago  211 MB
    ```
-   The preceding output shows that the image tag is `latest` and that the image ID is `a1f8c96699786`.
    <br>

-   To run a container from this image, use the `podman run` command.
-   When we execute a `podman run` command, we create and start a new container from a container image.
-   Use the `-it` options to interact with the container, if required. The `-it` options allocate a terminal to the container and allow us to send keystrokes to it.<br> `$ podman run -it registry.access.redhat.com/ubi8/ubi:latest`

-   **Important**
    -   If we run a container using the fully qualified image name, but the image is not yet stored locally, then the `podman run` command first pulls the image from the registry, and then runs.
-   **Note**

    -   Many Podman flags also have an alternative long form; some of these are explained below.

            - `-t` is equivalent to `--tty`, meaning a `pseudo-tty` (pseudo-terminal) is allocated for the container.

            - `-i` is the same as `--interactive`. When this option is used, the container accepts standard input.

            - `-d`, or its long form `--detach`, means the container runs in the background (detached). When this option is used, Podman runs the container in the background and displays its generated container ID.

        <br>

-   When referencing a container, Podman recognizes either the container name or the generated container ID.
-   Use the `--name` option to set the container name when running the container with Podman.
-   Container names must be unique. If the podman run command includes no container name, Podman generates a unique random name.
    <br>

-   The following example assigns the container a name, explicitly starts a Bash terminal inside the container, and interactively runs a command in it :

    ````
    [user@host ~]$ podman run -it --name=rhel8 registry.access.redhat.com/ubi8/ubi /bin/bash
    [root@c20631116955 /]# cat /etc/os-release
    NAME="Red Hat Enterprise Linux"
    VERSION="8.2 (Ootpa)"
    ID="rhel"
    ID_LIKE="fedora"
    VERSION_ID="8.2"
    PLATFORM_ID="platform:el8"
    PRETTY_NAME="Red Hat Enterprise Linux 8.2 (Ootpa)"
    ANSI_COLOR="0;31"
    CPE_NAME="cpe:/o:redhat:enterprise_linux:8.2:GA"
    HOME_URL="https://www.redhat.com/"
    BUG_REPORT_URL="https://bugzilla.redhat.com/"

        REDHAT_BUGZILLA_PRODUCT="Red Hat Enterprise Linux 8"
        REDHAT_BUGZILLA_PRODUCT_VERSION=8.2
        REDHAT_SUPPORT_PRODUCT="Red Hat Enterprise Linux"
        REDHAT_SUPPORT_PRODUCT_VERSION="8.2"
        [root@c20631116955 /]# exit
        exit
        [user@host ~]$
        ```

    <br>

    ````

-   **Note**
    -   Note that the `latest` tag is assumed when no tag is explicitly specified.

<br>

-   We can also run a quick command in a container without interacting with it, and then remove the container once the command is completed.
-   To do this, use `podman run --rm` followed by the container image and a command.

    ```
    $ podman run -rm registry.access.redhat.com/ubi8/ubi cat/etc/os-release
    NAME="Red Hat Enterprise Linux"
    VERSION="8.2 (Ootpa)"
    ID="rhel"
    ID_LIKE="fedora"
    VERSION_ID="8.2"
    PLATFORM_ID="platform:el8"
    PRETTY_NAME="Red Hat Enterprise Linux 8.2 (Ootpa)"
    ANSI_COLOR="0;31"
    CPE_NAME="cpe:/o:redhat:enterprise_linux:8.2:GA"
    HOME_URL="https://www.redhat.com/"
    BUG_REPORT_URL="https://bugzilla.redhat.com/"

    REDHAT_BUGZILLA_PRODUCT="Red Hat Enterprise Linux 8"
    REDHAT_BUGZILLA_PRODUCT_VERSION=8.2
    REDHAT_SUPPORT_PRODUCT="Red Hat Enterprise Linux"
    REDHAT_SUPPORT_PRODUCT_VERSION="8.2"
    ```

#### Analyzing Container Isolation

-   Containers provide run time isolation of resources.
-   Containers utilize Linux namespaces to provide separate, isolated environments for resources, such as processes, network communications, and volumes.
-   Processes running within a container are isolated from all other processes on the host machine.
    <br>

-   View the processes running inside the container :
    ```
    [user@host ~]$ podman run -it registry.access.redhat.com/ubi8/ubi /bin/bash
    [root@ef2550ed815d /]# ps aux
    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root           1  4.5  0.1  11840  2904 pts/0    Ss   22:10   0:00 /bin/bash
    root          15  0.0  0.1  51768  3388 pts/0    R+   22:10   0:00 ps aux
    ```
-   Note that the user name and ID inside the container is different from the user name and ID on the host machine :
    ```
    [root@ef2550ed815d /]# id
    uid=0(root) gid=0(root) groups=0(root)
    [root@ef2550ed815d /]# exit
    exit
    [user@host ~]$ id
    uid=1000(user) gid=1000(user) groups=1000(user),10(wheel)
    ```

### Finding and Managing Container Images

#### Configuring Container Registries

-   Podman uses a `registries.conf` file on your host system to get information about the container registries it can use.

    ```
    $  cat /etc/containers/registries.conf
    # This is a system-wide configuration file used to
    # keep track of registries for various container backends.
    # It adheres to TOML format and does not support recursive
    # lists of registries.

    # The default location for this configuration file is /etc/containers/registries.conf.

    # The only valid categories are: 'registries.search', 'registries.insecure',
    # and 'registries.block'.

    [registries.search]
    registries = ['registry.redhat.io', 'quay.io', 'docker.io']

    # If you need to access insecure registries, add the registry's fully-qualified name.
    # An insecure registry is one that does not have a valid SSL certificate or only does HTTP.
    [registries.insecure]
    registries = []

    # If you need to block pull access from a registry, uncomment the section below
    # and add the registries fully-qualified name.
    #
    [registries.block]
    registries = []
    ```

-   **Important**

    -   For a regular (rootless) user of Podman, this file is stored in the `$HOME/.config/`containers directory.
    -   Configuration settings in this file override the system-wide settings in the `/etc/containers/registries.conf` file.
        <br>

    -   The list of registries that Podman can search are configured in the `[registries.search]` section of this file.
    -   If we do not specify a fully qualified image on the command line, then Podman will search this section in the order listed to determine how to form a complete image path.
        <br>

    -   The `podman info` command displays configuration information for Podman, including its configured registries.
        ```
        $ podman info
        ...output omitted...
        insecure registries:
        registries: []
        registries:
        registries:
        - registry.redhat.io
        - quay.io
        - docker.io
        ...output omitted...
        ```

##### Registry Securiity

-   Insecure registries are listed in the `[registries.insecure]` section of the `registries.conf` file.
-   If a registry is listed as insecure, then connections to that registry are not protected with TLS encryption.
-   If a registry is both searchable and insecure, then it can be listed in both `[registries.search]` and `[registries.insecure]`.
    <br>

-   Container registries can also be configured to require authentication.
-   As previously discussed, we use the `$ podman login` command to log in to a container registry that requires authentication.

#### Finding Container Images

-   Use the `podman search` command to search container registries for a specific container image.
-   The following example shows how to search the container registry `registry.redhat.io` for all images that include the name `rhel8` :
    ```
    $ podman search registry.redhat.io/rhel8
    INDEX       NAME          DESCRIPTION                STARS   OFFICIAL   AUTOMATED
    redhat.io   registry.redhat.io/openj9/openj9-8-rhel8      OpenJ9 1.8 OpenShift S2I image for Java Appl...   0
    redhat.io   registry.redhat.io/openjdk/openjdk-8-rhel8    OpenJDK 1.8 Image for Java Applications base...   0
    redhat.io   registry.redhat.io/openj9/openj9-11-rhel8     OpenJ9 11 OpenShift S2I image for Java Appli...   0
    redhat.io   registry.redhat.io/openjdk/openjdk-11-rhel8   OpenJDK S2I image for Java Applications on U...   0
    redhat.io   registry.redhat.io/rhel8/memcached            Free and open source, high-performance, dist...   0
    redhat.io   registry.redhat.io/rhel8/llvm-toolset         The LLVM back-end compiler and core librarie...   0
    redhat.io   registry.redhat.io/rhel8/rust-toolset         Rust and Cargo, which is a build system and ...   0
    redhat.io   registry.redhat.io/rhel8/go-toolset           Golang compiler which will replace the curre...   0
    ...output omitted...
    ```
-   Run the same command with the `--no-trunc` option to see longer image descriptions :

    ```
    $ podman search --no-trunc registry.access.redhat.com/rhel8
    INDEX       NAME          DESCRIPTION                STARS   OFFICIAL   AUTOMATED
    ...output omitted...
    redhat.io   registry.redhat.io/rhel8/nodejs-10            Node.js 10 available as container is a base platform for building and running various Node.js 10 applications and frameworks. Node.js is a platform built on Chrome's JavaScript runtime for easily building fast, scalable network applications. Node.js uses an event-driven, non-blocking I/O model that makes it lightweight and efficient, perfect for data-intensive real-time applications that run across distributed devices.          0

    redhat.io   registry.redhat.io/rhel8/python-36            Python 3.6 available as container is a base platform for building and running various Python 3.6 applications and frameworks. Python is an easy to learn, powerful programming language. It has efficient high-level data structures and a simple but effective approach to object-oriented programming.          0

    redhat.io   registry.redhat.io/rhel8/perl-526             Perl 5.26 available as container is a base platform for building and running various Perl 5.26 applications and frameworks. Perl is a high-level programming language with roots in C, sed, awk and shell scripting. Perl is good at handling processes and files, and is especially good at handling text.         0
    ...output omitted...
    ```

-   The following table shows some other useful options for the `podman search` command :

| Option                    | Description                                                                                                                                                                       |
| ------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------------------------------------- | ---------------------------------------------- |
| `--limit <number>`        | Limits the number of listed images per registry                                                                                                                                   |
| `--filter <filter=value>` | Filters output based on conditions provided. Supported filters include : <br> - `stars=<number>` : Show only images with at least this number of stars <br> - `is-automated=<true | false>`: Show only images automatically built. <br> -`is-official=<true                  | false>` : Show only images flagged as official |
| `--tls-verify <true       | false>`                                                                                                                                                                           | Enables or disables HTTPS certificate validation for all used registries. Default=`true` |

#### Using the Red Hat Container Catalog

-   Red Hat maintains repositories containing certified container images. We can access a web interface to search them at https://access.redhat.com/containers.
    <br>

-   Using this repository provides customers with a layer of protection and reliability against known vulnerabilities that could potentially be caused by untested images.
-   The standard `podman` command is compatible with the repositories referenced by the Red Hat Container Catalog.

#### Inspecting Container Images

-   We can view information about an image before downloading it to our system.
-   The `skopeo inspect` command can inspect a remote container image in a registry and display information about it.
    <br>

-   The following example inspects a container image and returns image information without pulling the image to the local system :
    ```
    $ skopeo inspect docker://registry.redhat.io/rhel8/python-36
    ...output omitted...
                    "name": "ubi8/python-36",
                    "release": "107",
                    "summary": "Platform for building and running Python 3.6 applications",
    ...output omitted...
    ```
-   **Note**

    -   The `skopeo inspect` command can inspect different image formats from different sources, such as remote registries or local directories.
    -   The `docker://` transport mechanism instructs `skopeo` to query a container image registry.
        <br>

-   We can also inspect locally stored image information using the `podman inspect` command.
-   This command might provide more information than the `skopeo inspect` command.
    <br>

-   List locally stored images :
    ```
    $ podman images
    REPOSITORY                            TAG      IMAGE ID       CREATED       SIZE
    quay.io/generic/rhel7                 latest   1d3b6b7d01e4   3 weeks ago   688 MB
    registry.redhat.io/rhel8/python-36    latest   e55cd9a2e0ca   6 weeks ago   811 MB
    registry.redhat.io/ubi8/ubi           latest   a1f8c9699786   6 weeks ago   211 MB
    ```
-   Inspect a locally stored image and return information :
    ```
    $ podman inspect registry.redhat.io/rhel8/python-36
    ...output omitted...
            "Config": {
                "User": "1001",
                "ExposedPorts": {
                    "8080/tcp": {}
    ...output omitted...
                    "name": "ubi8/python-36",
                    "release": "107",
                    "summary": "Platform for building and running Python 3.6 applications",
    ...output omitted...
    ```

#### Removing Local Container Images

-   Container images are immutable; they do not change.
-   This means that old images are not updated, so updating software in a container requres a new image that replaces the old one.
    <br>

-   When an updated image is made available, the publisher changes the latest tag to associate it with the new image.
-   We can still access an older image by referencing its specific version tag, and we can run containers from it.
-   We can also remove the older image, pull the latest image, and only use the latest (updated) image to run containers.
    <br>

-   For example, images provided by Red Hat benefit from the long experience Red Hat has in managing security vulnerabilities and defects in Red Hat Enterprise Linux and other products.
-   The Red Hat security team hardens and controls these high quality images.
-   They are rebuilt when new vulnerabilities are discovered and go through a quality assurance process.
    <br>

-   To remove a locally stored image, use the `podman rmi` command.
    <br>

-   List locally stored images :
    ```
    $ podman images
    REPOSITORY                            TAG      IMAGE ID       CREATED       SIZE
    quay.io/generic/rhel7                 latest   1d3b6b7d01e4   3 weeks ago   688 MB
    registry.redhat.io/rhel8/python-36    latest   e55cd9a2e0ca   6 weeks ago   811 MB
    registry.redhat.io/ubi8/ubi           latest   a1f8c9699786   6 weeks ago   211 MB
    ```
-   Remove the `registry.redhat.io/rhel8/python-36:latest` image.
    ```
    $ podman rmi registry.redhat.io/rhel8/python-36:latest
    e55cd9a2e0ca5f0f4e0249404d1abe3a69d4c6ffa5103d0512dd4263374063ad
    ```
-   List locally stored images and verify that it was removed :
    ```
    $ podman images
    REPOSITORY                            TAG      IMAGE ID       CREATED       SIZE
    quay.io/generic/rhel7                 latest   1d3b6b7d01e4   3 weeks ago   688 MB
    registry.redhat.io/ubi8/ubi           latest   a1f8c9699786   6 weeks ago   211 MB
    ```
