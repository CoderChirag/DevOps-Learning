## Running Containers

### Introducing Containers

#### Introducing Container Technology

-   Software applications typically depend on other libraries, configuration files, or services provided by their runtime environment.
-   Traditionally, the runtime environment for a software application is installed in an operating system running on a physical host or virtual machine.
-   Any application dependencies are installed along with that operating system on the host.
    <br>

-   In Red Hat Enterprise Linux, packaging systems like RPM are used to help manage application dependencies.
-   When we install the `httpd` package, the RPM system ensures that the correct libraries and other dependencies for that package are also installed.
    <br>

-   The major drawback to traditionally deployed software applications is that these dependencies are entangled with the runtime environment.
-   An application might require versions of supporting software that are older or newer than the software provided with the operating system.
-   Similarly, two applications on the same system might require different versions of the same software that are incompatible with each other.
    <br>

-   One way to resolve these conflicts is to package and deploy the application as a container.
-   A **container** is a set of one or more processes that are isolated from the rest of the system.
    <br>

-   Think of a physical shipping container.
-   A shipping container is a standard way to package and ship goods.
-   It is labeled, loaded, unloaded, and transported from one location to another as a single box.
-   The container's contents are isolated from the contents of other containers so that they do not affect each other.
    <br>

-   Software containers are a way to package applications to simplify deployment and management.

#### Comparing Containers to Virtual Machines

-   Containers provide many of the same benefits as virtual machines, such as security, storage, and network isolation.
    <br>

-   Both technologies isolate their application libraries and runtime resources from the host operating system or hypervisor and vice versa.
    ![virtualization_vs_containers](./images/virtualization-vs-containers.png)
    <br>

-   Containers and Virtual Machines are different in the way they interact with hardware and the underlying operating system.
    <br>

-   **Virtualization :**

    -   Enables multiple operating systems to run simultaneously on a single hardware platform.
    -   Uses a **hypervisor** to divide hardware into multiple virtual hardware systems, allowing multiple operating systems to run side by side.
    -   Requires a complete operating system environment to support the application.
        <br>

-   Compare and contrast this with **Containers**, which :

    -   Run directly on the operating system, sharing hardware and OS resources across all containers on the system. This enables applications to stay lightweight and run swiftly in parallel.
    -   Share the same operating system kernel, isolate the containerized application processes from the rest of the system, and use any software compatible with that kernel.
    -   Require far fewer hardware resources than virtual machines, which also makes them quick to start and stop and reduces storage requirements.
        <br>

-   **Note**
    -   Some applications might not be suitable to run as a container. For example, applications accessing low-level hardware information might need more direct hardware access than containers generally provide.

#### Exploring the Implementation of Containers

-   Red Hat Enterprise Linux implements containers using core technologies such as :

    -   **Control Groups** (cgroups) for resource management.
    -   **Namespaces** for process isolation.
    -   **SELinux** and **Seccomp** (Secure Computing mode) to enforce security boundaries.

#### Planning for Containers

-   Containers are an efficient way to provide reusability and portability of hosted applications.
-   They can be easily moved from one environment to another, such as from development to production.
-   We can save multiple versions of a container and quickly access each one as needed.
    <br>

-   Containers are typically temporary, or ephemeral.
-   We can permanently save data generated by a running container in persistent storage, but the containers themselves usually run when needed, and then stop and are removed.
-   A new container process is started the next time that particular container is needed.

#### Running Containers from Container Images

-   Containers are run from container images. Container images serve as blueprints for creating containers.
    <br>

-   Container images package an application together with all its dependencies, such as :

    -   System libraries
    -   Programming language runtimes
    -   Programming language libraries
    -   Configuration settings
    -   Static data files

-   Container images are unchangeable, or immutable, files that include all the required code and dependencies to run a container.
    <br>

-   Container images are built according to specifications, such as the **Open Container Initiative (OCI)** image format specification.
-   These specifications define the format for container images, as well as the metadata about the container host operating systems and hardware architectures that the image supports.

#### Designing Container-based Architectures

-   We could install a complex software application made up of multiple services in a single container.
-   For example, we might have a web server that needs to use a database and a messaging system. But using one container for multiple services is hard to manage.
    <br>

-   A better design runs each component, the web server, the database, and the messaging system, in separate containers.
-   This way, updates and maintenance to individual application components do not affect other components or the application stack.

#### Managing Containers with Podman

-   A good way to start learning about containers is to work with individual containers on a single server acting as a container host.
-   Red Hat Enterprise Linux provides a set of container tools that we can use to do this, including :
    -   `podman`, which directly manages containers and container images.
    -   `skopeo`, which we can use to inspect, copy, delete, and sign images.
    -   `buildah`, which we can use to create new container images.
-   These tools are compatible with the **Open Container Initiative (OCI)**.
-   They can be used to manage any Linux containers created by OCI-compatible container engines, such as Docker.
-   These tools are specifically designed to run containers under Red Hat Enterprise Linux on a single-node container host.
    <br>

-   In this chapter, we will use `podman` and `skopeo` commands to run and manage containers and existing container images.

#### Running Rootless Containers

-   On the container host, we can run containers as the root user or as a regular, unprivileged user.
-   Containers run by non-privileged users are called **rootless containers**.
    <br>

-   Rootless containers are more secure, but have some restrictions.
-   For example, rootless containers cannot publish their network services through the container host's privileged ports (those below port 1024).
    <br>

-   We can run containers directly as root, if necessary, but this somewhat weakens the security of the system if a bug allows an attacker to compromise the container.

#### Managing Containers at Scale

-   New applications increasingly implement functional components using containers.
-   Those containers provide services that other parts of the application consume.
-   In an organization, managing a growing number of containers may quickly become an overwhelming task.
    <br>

-   Deploying containers at scale in production requires an environment that can adapt to some of the following challenges :

    -   The platform must ensure the availability of containers that provide essential services to customers.
    -   The environment must respond to application usage spikes by increasing or decreasing the running containers and load balancing the traffic.
    -   The platform should detect the failure of a container or a host and react accordingly.
    -   Developers might need an automated workflow to transparently and securely deliver new application versions to customers.
        <br>

-   **Kubernetes** is an orchestration service that makes it easier for us to deploy, manage, and scale container-based applications across a cluster of container hosts.
-   It helps manage DNS updates when we start new containers.
-   It helps redirect traffic to our containers using a load balancer, which also allows us to scale up and down the number of containers providing a service manually or automatically.
-   It also supports user-defined health checks to monitor our containers and to restart them if they fail.
    <br>

-   Red Hat provides a distribution of Kubernetes called **Red Hat OpenShift**.
-   OpenShift is a set of modular components and services built on top of the Kubernetes infrastructure.
-   It adds additional features, such as remote web-based management, multitenancy, monitoring and auditing, application life cycle management, and self-service instances for developers, among others.

-   **Note**

    -   In the enterprise, individual containers are not generally run from the command line.
    -   Instead, it is preferable to run containers in production using a Kubernetes-based platform, such as Red Hat OpenShift.
        <br>

    -   However, we might need to use commands to work with containers and images manually or at a small scale.
    -   To do this, we can install a set of container tools on a Red Hat Enterprise Linux 8 system.
        <br>
    -   This chapter focuses on this use case to help us better understand the core concepts behind containers, how they work, and how they can be useful.

### Running a Basic Container

#### Installing Container Management Tools

-   To get started with running and managing containers on our system, we must install the necessary command-line tools. Install the `container-tools` module with the `yum` command.<br> `$ yum module install container-tools`
    <br>
-   The `container-tools` module includes software packages that install several tools.
    <br>

-   **Note**

    -   By default, the system installs the fast stream tools, `container-tools:rhel8` that rebase on the latest, stable upstream version of the container tools every three months.
        <br>

    -   Alternative stable streams that lock in a particular version of the tools do not get feature updates. Red Hat plans to release new stable streams once a year that are supported for two years.

#### Selecting Container Images and Registries

-   A container registry is a repository for storing and retrieving container images.
-   Container images are uploaded, or pushed, to a container registry by a developer.
-   We download, or pull, those container images from the registry to a local system so that we can use them to run containers.
    <br>

-   we might use a public registry containing third-party images, or we might use a private registry controlled by our organization.
-   The source of our container images matters.
-   Just like any other software package, we must know whether we can trust the code in the container image.
-   Different registries have different policies about whether and how they provide, evaluate, and test container images submitted to them.
    <br>

-   Red Hat distributes certified container images through two main container registries that we can access with our Red Hat log in credentials.

    -   `registry.redhat.io` for containers based on official Red Hat products.
    -   `registry.connect.redhat.com` for containers based on third-party products.
        <br>

-   Red Hat is gradually phasing out an older registry, `registry.access.redhat.com`.
    <br>

-   The Red Hat Container Catalog (https://access.redhat.com/containers) provides a web-based interface that we can use to search these registries for certified content.

#### Container Naming Conventions

-   Container images are named based on the following fully qualified image name syntax :

-   `registry_name/user_name/image_name:tag`

    -   The `registry_name` is the name of the registry storing the image. It is usually the fully qualified domain name of the registry.

    -   The `user_name` represents the user or organization to which the image belongs.

    -   The `image_name` must be unique in the user namespace.

    -   The `tag` identifies the image version. If the image name includes no image tag, then latest is assumed.

#### Running Containers

-   To run a container on our local system, we must first pull a container image.
-   Use Podman to pull an image from a registry.
-   We should always use the fully qualified image name when pulling images.
-   The `podman pull` command pulls the image we specify from the registry and saves it locally :
    ```
    $ podman pull registry.access.redhat.com/ubi8/ubi:latest
    Trying to pull registry.access.redhat.com/ubi8/ubi:latest...Getting image source signatures
    Copying blob 77c58f19bd6e: 70.54 MiB / 70.54 MiB [=========================] 10s
    Copying blob 47db82df7f3f: 1.68 KiB / 1.68 KiB [===========================] 10s
    Copying config a1f8c9699786: 4.26 KiB / 4.26 KiB [==========================] 0s
    Writing manifest to image destination
    Storing signatures
    a1f8c969978652a6d1b2dfb265ae0c6c346da69000160cd3ecd5f619e26fa9f3
    ```
-   After retrieval, Podman stores images locally and we can list them using the `podman images` command :
    ```
    $ podman images
    REPOSITORY                            TAG      IMAGE ID       CREATED      SIZE
    registry.access.redhat.com/ubi8/ubi   latest   a1f8c9699786   5 weeks ago  211 MB
    ```
-   The preceding output shows that the image tag is `latest` and that the image ID is `a1f8c96699786`.
    <br>

-   To run a container from this image, use the `podman run` command.
-   When we execute a `podman run` command, we create and start a new container from a container image.
-   Use the `-it` options to interact with the container, if required. The `-it` options allocate a terminal to the container and allow us to send keystrokes to it.<br> `$ podman run -it registry.access.redhat.com/ubi8/ubi:latest`

-   **Important**
    -   If we run a container using the fully qualified image name, but the image is not yet stored locally, then the `podman run` command first pulls the image from the registry, and then runs.
-   **Note**

    -   Many Podman flags also have an alternative long form; some of these are explained below.

            - `-t` is equivalent to `--tty`, meaning a `pseudo-tty` (pseudo-terminal) is allocated for the container.

            - `-i` is the same as `--interactive`. When this option is used, the container accepts standard input.

            - `-d`, or its long form `--detach`, means the container runs in the background (detached). When this option is used, Podman runs the container in the background and displays its generated container ID.

        <br>

-   When referencing a container, Podman recognizes either the container name or the generated container ID.
-   Use the `--name` option to set the container name when running the container with Podman.
-   Container names must be unique. If the podman run command includes no container name, Podman generates a unique random name.
    <br>

-   The following example assigns the container a name, explicitly starts a Bash terminal inside the container, and interactively runs a command in it :
    ```
    [user@host ~]$ podman run -it --name=rhel8 registry.access.redhat.com/ubi8/ubi /bin/bash
    [root@c20631116955 /]# cat /etc/os-release
    NAME="Red Hat Enterprise Linux"
    VERSION="8.2 (Ootpa)"
    ID="rhel"
    ID_LIKE="fedora"
    VERSION_ID="8.2"
    PLATFORM_ID="platform:el8"
    PRETTY_NAME="Red Hat Enterprise Linux 8.2 (Ootpa)"
    ANSI_COLOR="0;31"
    CPE_NAME="cpe:/o:redhat:enterprise_linux:8.2:GA"
    HOME_URL="https://www.redhat.com/"
    BUG_REPORT_URL="https://bugzilla.redhat.com/"

        REDHAT_BUGZILLA_PRODUCT="Red Hat Enterprise Linux 8"
        REDHAT_BUGZILLA_PRODUCT_VERSION=8.2
        REDHAT_SUPPORT_PRODUCT="Red Hat Enterprise Linux"
        REDHAT_SUPPORT_PRODUCT_VERSION="8.2"
        [root@c20631116955 /]# exit
        exit
        [user@host ~]$
        ```

    <br>

-   **Note**
    -   Note that the `latest` tag is assumed when no tag is explicitly specified.

<br>

-   We can also run a quick command in a container without interacting with it, and then remove the container once the command is completed.
-   To do this, use `podman run --rm` followed by the container image and a command.

    ```
    $ podman run -rm registry.access.redhat.com/ubi8/ubi cat/etc/os-release
    NAME="Red Hat Enterprise Linux"
    VERSION="8.2 (Ootpa)"
    ID="rhel"
    ID_LIKE="fedora"
    VERSION_ID="8.2"
    PLATFORM_ID="platform:el8"
    PRETTY_NAME="Red Hat Enterprise Linux 8.2 (Ootpa)"
    ANSI_COLOR="0;31"
    CPE_NAME="cpe:/o:redhat:enterprise_linux:8.2:GA"
    HOME_URL="https://www.redhat.com/"
    BUG_REPORT_URL="https://bugzilla.redhat.com/"

    REDHAT_BUGZILLA_PRODUCT="Red Hat Enterprise Linux 8"
    REDHAT_BUGZILLA_PRODUCT_VERSION=8.2
    REDHAT_SUPPORT_PRODUCT="Red Hat Enterprise Linux"
    REDHAT_SUPPORT_PRODUCT_VERSION="8.2"
    ```

#### Analyzing Container Isolation

-   Containers provide run time isolation of resources.
-   Containers utilize Linux namespaces to provide separate, isolated environments for resources, such as processes, network communications, and volumes.
-   Processes running within a container are isolated from all other processes on the host machine.
    <br>

-   View the processes running inside the container :
    ```
    [user@host ~]$ podman run -it registry.access.redhat.com/ubi8/ubi /bin/bash
    [root@ef2550ed815d /]# ps aux
    USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND
    root           1  4.5  0.1  11840  2904 pts/0    Ss   22:10   0:00 /bin/bash
    root          15  0.0  0.1  51768  3388 pts/0    R+   22:10   0:00 ps aux
    ```
-   Note that the user name and ID inside the container is different from the user name and ID on the host machine :
    ```
    [root@ef2550ed815d /]# id
    uid=0(root) gid=0(root) groups=0(root)
    [root@ef2550ed815d /]# exit
    exit
    [user@host ~]$ id
    uid=1000(user) gid=1000(user) groups=1000(user),10(wheel)
    ```
